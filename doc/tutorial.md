# LevelDB

## Round1

### 1. `Catch2`测试框架集成无法正常link

* 这里主要还是因为如果所有的测试代码都被封装成lib, 在linker进行link过程中, 最后构建的`unittest`作为executable, 并没有显示的调用测试用例, 这会导致出现**Dead Code Elimination**的问题, 也就是说linker非常的懒惰, 它只会按需取货, 没有在executable中出现的符号变量都不会被链接(直接丢弃).

* 程序的打包逻辑如下
  1. 编译阶段: 你的每一个`.cpp`都会变成一个`.o`(或 .obj)目标文件
  2. 打包阶段: 你把一堆`.o`打包成一个`.a`静态库
  3. 链接阶段: 链接器从你的`main.cpp`开始搜索, 看看需要哪些符号(函数, 变量)
  如果链接器发现`main.cpp`及其引用的代码里, 从来没有调用过静态库中某个文件(比如 plugin.cpp)里的任何函数, 链接器就会认为这个文件是多余的, 为了减小最终可执行文件的体积, 它会直接丢弃整个目标文件.

* 如何解决这个问题
  1. 使用特殊的链接方式, 将对应的测试文件打包的lib, 使用`-Wl,--whole-archive`和`-Wl,--no-whole-archive`包裹起来(对于clang和gcc)
  2. 手动骗一下编译器, 在executable中使用对应obj中的变量
  3. 如果使用的是gcc编译器, 可以在静态库的某个函数上添加`__attribute__((used))`

### 2. Arena的设计

1. Arena是一个自定义的内存分配器, 基本上是在用户态下进行内存分配, 因此速度要比`new`要快很多

2. 主要的核心逻辑就是说如果是一个小块, 就直接在已经准备好的大块内存中进行分配(在Allocate函数中, 直接进行指针偏移即可). 内存不够的情况下进行Fallback, 申请内存并且进行分配(这个函数相当于进行冷热分离)

3. 另外一点就是要考虑对齐分配的问题, 需要额外算一下对齐的偏移量

### 3. Adress sanitize (ASAN)

使用ASAN进行内存错误检测, 只需要在CMAKE中添加`set (CMAKE_CXX_FLAGS "-g -fsanitize=address")`

